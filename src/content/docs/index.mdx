---
title: Nylon
description: Get started with Nylon, a high-performance, extensible proxy server.
template: splash
hero:
  tagline: Nylon is a lightweight, high-performance, and extensible proxy server built on top of the robust Cloudflare Pingora framework. Designed for modern infrastructure.
  # image:
  #   file: ../../assets/houston.webp
  actions:
    - text: Get Started
      link: /getting-started/installation
      icon: right-arrow
    # - text: Read the Nylon docs
    #   link: https://nylon.sh/docs/getting-started/installation
    #   icon: external
    #   variant: minimal
---
import { Card, CardGrid } from '@astrojs/starlight/components';
import InstallBlock from './../../components/InstallBlock.mdx';

<div class="lp-cta-card">
  <Card title="Install Nylon" icon="rocket">
    <InstallBlock />
  </Card>
</div>

<CardGrid>
  <Card title="Flexible Plugin System" icon="puzzle">
    Freely extend Nylon's functionality through an FFI plugin system that communicates using FlatBuffers, enabling you to write plugins in languages like Go, Rust, Zig, and more.
  </Card>
  <Card title="Declarative Configuration" icon="document">
    Manage everything from routing and services to TLS through a single, easy-to-read, GitOps-friendly YAML file. Supports Dynamic Value Templating for maximum flexibility.
  </Card>
  <Card title="Advanced Routing" icon="seti:pipeline">
    Route traffic precisely based on `Host`, `Header`, and `Path` (with wildcard support), allowing you to create complex conditions for any use case.
  </Card>
  <Card title="Load Balancing" icon="seti:puppet">
    Distribute traffic to your backend services with industry-standard algorithms such as `Round Robin`, `Random`, and `Consistent Hashing` (Ketama).
  </Card>
  <Card title="Automatic TLS Management" icon="seti:lock">
    Supports automatic certificate generation and renewal via ACME (Let's Encrypt, Buypass, etc.), and easily integrates with your existing custom certificates.
  </Card>
  <Card title="Built on Pingora" icon="cloudflare">
    By being built on Pingora, Nylon inherits world-class performance, security, and stability that has been battle-tested at a global scale.
  </Card>
</CardGrid>

# Extending Nylon with the Go SDK

Nylon is designed to be extensible through a powerful plugin system. This page provides examples of how to write basic plugins using the Go SDK.

### Core Concepts

Writing a Nylon plugin with the Go SDK involves a few key functions and objects:

* **`InputToDispatcher`**: This function deserializes the raw data pointer passed from Nylon into a manageable `Dispatcher` object.
* **`Dispatcher`**: The central hub for your plugin. It provides access to the request/response context, plugin configuration, and methods to control the request lifecycle.
* **`HttpContext`**: An object containing all data for the current HTTP request and response. You can modify headers, the body, and the status code via this context.
* **`SetHttpEnd`**: A critical method on the `Dispatcher` that tells Nylon whether to terminate the request at this plugin or continue processing.
    * `true`: End the request and immediately send the response from this plugin back to the client. Ideal for Service Handlers.
    * `false`: Continue processing the request through the proxy chain. Ideal for Middleware.
* **`SendResponse`**: The final function called to serialize your plugin's output and return it to Nylon.

### Helper Function Definitions

The following helper functions manage the data conversion between Go and Nylon's C-based FFI layer. You will use these in your plugin's entrypoint functions.

```C
// nylon.h
#ifndef NYLON_H
#define NYLON_H

#include <stdlib.h>

typedef struct {
    const unsigned char *ptr;
    unsigned long len;
} FfiOutput;

#endif // NYLON_H
```

```go
// utils.go
package main

/*
#include "../../c/nylon.h"
*/
import "C"
import (
  "unsafe"

  "github.com/AssetsArt/nylon/sdk/go/sdk"
)

// SendResponse serializes the final Dispatcher object from Go back to a C pointer
// that Nylon can understand.
func SendResponse(sdk_dispatcher *sdk.Dispatcher) C.FfiOutput {
  output := sdk_dispatcher.ToBytes()
  return C.FfiOutput{
    ptr: (*C.uchar)(C.CBytes(output)),
    len: C.ulong(len(output)),
  }
}

// InputToDispatcher converts the C pointer and length from Nylon into a Go-native
// Dispatcher object for easy manipulation.
func InputToDispatcher(ptr *C.uchar, input_len C.int) *sdk.Dispatcher {
  input := C.GoBytes(unsafe.Pointer(ptr), C.int(input_len))
  dispatcher := sdk.WrapDispatcher(input)
  return dispatcher
}
```

The following examples show these concepts in action.

## Example 1: Middleware Plugin

A middleware plugin intercepts and modifies a request or response before it reaches its final destination. This example demonstrates how to add custom headers.

```go
//export sdk_go_mid_request_filter
func sdk_go_mid_request_filter(ptr *C.uchar, input_len C.int) C.FfiOutput {
    // 1. Convert raw input to a Dispatcher object.
    dispatcher := InputToDispatcher(ptr, input_len)
    // 2. Get the current HTTP context.
    ctx := dispatcher.SwitchDataToHttpContext()

    // 3. Modify the request and response headers.
    ctx.Request.SetHeader("x-nylon-middleware", "true")
    ctx.Response.SetHeader("x-nylon-request-filter", "true")

    // 4. Tell Nylon to continue processing the request.
    dispatcher.SetHttpEnd(false)
    // 5. Serialize the modified context back to bytes.
    dispatcher.SetData(ctx.ToBytes())
    // 6. Send the result back to Nylon.
    return SendResponse(dispatcher)
}
````

**Code Breakdown:**

  * `ctx.Request.SetHeader(...)`: Adds a custom header to the request before it's proxied to the backend service.
  * `ctx.Response.SetHeader(...)`: Adds a custom header to the response before it's sent back to the client.
  * `dispatcher.SetHttpEnd(false)`: This is the key instruction that defines this plugin as middleware. It tells Nylon not to terminate the request here, but to proceed to the next stage (e.g., the backend service).

## Example 2: Service Handler Plugin

A service handler acts as the final destination for a request. It generates a response directly and sends it back to the client without proxying to another backend.

```go
//export sdk_go_service
func sdk_go_service(ptr *C.uchar, input_len C.int) C.FfiOutput {
    // 1. Convert raw input to a Dispatcher object.
    dispatcher := InputToDispatcher(ptr, input_len)
    // 2. Get the current HTTP context.
    ctx := dispatcher.SwitchDataToHttpContext()

    // 3. Generate a new JSON response body.
    ctx.Response.BodyJSON(map[string]any{
        "request_id":  dispatcher.RequestId,
        "plugin_name": dispatcher.PluginName,
    })
    // 4. Set the response headers and status code.
    ctx.Response.SetHeader("x-nylon-service", "true")
    ctx.Response.SetStatusCode(200)

    // 5. Tell Nylon to end the request here and send this response.
    dispatcher.SetHttpEnd(true)
    // 6. Serialize the new context back to bytes.
    dispatcher.SetData(ctx.ToBytes())
    // 7. Send the result back to Nylon.
    return SendResponse(dispatcher)
}
```

**Code Breakdown:**

  * `ctx.Response.BodyJSON(...)`: Creates a new response body from a Go map, automatically setting the `Content-Type` to `application/json`.
  * `dispatcher.SetHttpEnd(true)`: This critical instruction defines the plugin as a service handler. It tells Nylon that the request lifecycle is complete and that this generated response should be sent directly to the client.

### Next Steps

For complete, runnable implementations and their corresponding configurations, please see the [Go examples directory](https://github.com/AssetsArt/nylon/tree/main/examples/go) in our repository.